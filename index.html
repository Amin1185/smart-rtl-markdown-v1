<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Previewer</title>
    <meta name="description" content="Smart RTL-aware Markdown previewer with MathJax, Prism, and Tailwind-like styles.">
    
    <!-- =============================================
         EXTERNAL DEPENDENCIES
         ============================================= -->
    
    <!-- Tailwind CSS - Utility-first CSS framework -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    
    <!-- Marked.js - Fast Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Prism.js - Syntax highlighting for code blocks -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <!-- MathJax - LaTeX math rendering with RTL language support -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],       // Single $ for inline math
                displayMath: [['$$', '$$']],    // Double $$ for block math
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                // Don't process math inside these HTML tags
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            },
            chtml: {
                mtextInheritFont: true,  // Use document font for \text{} commands
                scale: 1
            },
            svg: {
                mtextInheritFont: true,
                scale: 1
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    window.mathJaxReady = true;  // Flag to check if MathJax is ready
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Google Fonts - Vazirmatn for Persian, Inter for Latin, JetBrains Mono for code -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- =============================================
         STYLES
         ============================================= -->
    <style>
        /* ----- CSS Variables ----- */
        :root {
            --border-radius: 12px;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Vazirmatn', sans-serif;
            background: #f8fafc;
            min-height: 100vh;
        }

        /* ----- Card Styling ----- */
        .card {
            background: white;
            border: 1px solid #e2e8f0;
            box-shadow: var(--shadow-sm);
            border-radius: var(--border-radius);
        }

        /* ----- Editor Textarea ----- */
        .editor-textarea {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.7;
            resize: none;
            background: #1e293b;
            color: #e2e8f0;
            border: none;
        }

        .editor-textarea::placeholder {
            color: #64748b;
        }

        .editor-textarea:focus {
            outline: none;
        }

        /* ----- Preview Container ----- */
        .preview-container {
            overflow-x: auto;
            overflow-y: auto;
        }

        /* ----- Markdown Output Base Styles ----- */
        .markdown-body {
            font-family: 'Vazirmatn', 'Inter', sans-serif;
            line-height: 1.8;
            color: #334155;
        }

        /* ----- RTL/LTR Direction Handling ----- */
        .markdown-body [dir="rtl"] {
            direction: rtl;
            text-align: right;
        }

        .markdown-body [dir="ltr"] {
            direction: ltr;
            text-align: left;
        }

        /* RTL list padding adjustment */
        .markdown-body ul[dir="rtl"], 
        .markdown-body ol[dir="rtl"] {
            padding-left: 0;
            padding-right: 2em;
        }

        .markdown-body ul[dir="ltr"], 
        .markdown-body ol[dir="ltr"] {
            padding-left: 2em;
            padding-right: 0;
        }

        /* RTL blockquote border adjustment */
        .markdown-body blockquote[dir="rtl"] {
            border-left: none;
            border-right: 3px solid #cbd5e1;
            padding-right: 1em;
            padding-left: 0;
        }

        .markdown-body blockquote[dir="ltr"] {
            border-right: none;
            border-left: 3px solid #cbd5e1;
            padding-left: 1em;
            padding-right: 0;
        }

        /* ----- Typography ----- */
        .markdown-body h1 {
            font-size: 1.875em;
            font-weight: 700;
            margin: 0.67em 0;
            color: #0f172a;
        }

        .markdown-body h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 0.83em 0;
            color: #1e293b;
        }

        .markdown-body h3 {
            font-size: 1.25em;
            font-weight: 600;
            margin: 1em 0;
            color: #334155;
        }

        .markdown-body h4 {
            font-size: 1.1em;
            font-weight: 600;
            margin: 1em 0;
            color: #475569;
        }

        .markdown-body p {
            margin-bottom: 1em;
            color: #475569;
            overflow-wrap: break-word;
        }

        .markdown-body strong {
            font-weight: 600;
            color: #1e293b;
        }

        .markdown-body em {
            font-style: italic;
        }

        /* ----- Lists ----- */
        .markdown-body ul, .markdown-body ol {
            margin-bottom: 1em;
            padding-left: 2em;
        }

        .markdown-body ul {
            list-style-type: disc;
        }

        .markdown-body ol {
            list-style-type: decimal;
        }

        .markdown-body li {
            margin-bottom: 0.25em;
            color: #475569;
        }

        /* ----- Links ----- */
        .markdown-body a {
            color: #2563eb;
            text-decoration: none;
        }

        .markdown-body a:hover {
            text-decoration: underline;
        }

        /* ----- Inline Code ----- 
           Uses unicode-bidi: isolate to prevent RTL text from affecting code direction */
        .markdown-body code:not([class*="language-"]) {
            background: #f1f5f9;
            padding: 0.15em 0.4em;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875em;
            color: #0f172a;
            unicode-bidi: isolate;
            direction: ltr;
            display: inline-block;
            vertical-align: baseline;
            white-space: nowrap;
        }

        /* ----- Code Blocks ----- */
        .markdown-body pre {
            margin: 1em 0;
            border-radius: 8px;
            overflow-x: auto;
            overflow-y: hidden;
            direction: ltr !important;
            text-align: left !important;
            max-width: 100%;
        }

        .markdown-body pre code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875em;
            line-height: 1.6;
            display: block;
            min-width: max-content;
            unicode-bidi: normal;
            white-space: pre;
        }

        /* ----- Blockquotes ----- */
        .markdown-body blockquote {
            margin: 1em 0;
            padding: 0.5em 1em;
            background: #f8fafc;
            border-left: 3px solid #cbd5e1;
            color: #64748b;
            overflow-x: auto;
        }

        /* ----- Horizontal Rules ----- */
        .markdown-body hr {
            border: none;
            height: 1px;
            background: #e2e8f0;
            margin: 2em 0;
        }

        /* ----- Tables ----- */
        .markdown-body .table-wrapper {
            overflow-x: auto;
            margin: 1em 0;
        }

        .markdown-body table {
            width: 100%;
            min-width: 400px;
            border-collapse: collapse;
        }

        .markdown-body th, .markdown-body td {
            padding: 0.5em 1em;
            border: 1px solid #e2e8f0;
            text-align: left;
        }

        .markdown-body th {
            background: #f8fafc;
            font-weight: 600;
            color: #334155;
        }

        .markdown-body td {
            background: white;
        }

        /* ----- MathJax Inline ----- 
           Ensures inline math doesn't cause layout issues */
        mjx-container:not([display="true"]) {
            display: inline-block !important;
            overflow: visible !important;
            vertical-align: middle !important;
            margin: 0 2px !important;
            padding: 0 !important;
            max-width: none !important;
        }

        /* ----- MathJax Block/Display ----- */
        mjx-container[display="true"] {
            display: block !important;
            margin: 1em auto !important;
            padding: 1em;
            background: #fffbeb;
            border-radius: 8px;
            border: 1px solid #fef3c7;
            text-align: center !important;
            direction: ltr !important;
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
        }

        /* Allow Persian/Arabic text in MathJax to use proper font */
        mjx-mtext {
            font-family: 'Vazirmatn', 'Inter', sans-serif !important;
        }

        /* ----- Footnotes ----- */
        .markdown-body .footnotes {
            margin-top: 2em;
            padding-top: 1em;
            border-top: 1px solid #e2e8f0;
            font-size: 0.9em;
            color: #64748b;
        }

        .markdown-body .footnotes ol {
            padding-left: 1.5em;
        }

        .markdown-body .footnotes li {
            margin-bottom: 0.5em;
        }

        .markdown-body .footnotes li p {
            display: inline;
            margin: 0;
        }

        .markdown-body .footnote-ref {
            font-size: 0.75em;
            vertical-align: super;
            line-height: 0;
        }

        .markdown-body .footnote-ref a {
            text-decoration: none;
            color: #2563eb;
            padding: 0 2px;
        }

        .markdown-body .footnote-ref a:hover {
            text-decoration: underline;
        }

        .markdown-body .footnote-backref {
            text-decoration: none;
            margin-left: 0.5em;
        }

        /* ----- BDI Elements -----
           Used to isolate Latin text sequences in RTL content */
        .markdown-body bdi {
            unicode-bidi: isolate;
        }

        /* ----- Scrollbar Styling ----- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Dark scrollbar for editor and code blocks */
        .editor-textarea::-webkit-scrollbar-track,
        pre::-webkit-scrollbar-track {
            background: #334155;
        }

        .editor-textarea::-webkit-scrollbar-thumb,
        pre::-webkit-scrollbar-thumb {
            background: #64748b;
        }

        /* ----- Panel Header ----- */
        .panel-header {
            display: flex;
            gap: 6px;
            padding: 10px 14px;
            background: #1e293b;
            border-bottom: 1px solid #334155;
        }

        .panel-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .panel-dot.red { background: #f87171; }
        .panel-dot.yellow { background: #fbbf24; }
        .panel-dot.green { background: #4ade80; }

        /* ----- Status Badge ----- */
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .status-badge.mixed {
            background: #f1f5f9;
            color: #475569;
        }

        .status-badge.rtl {
            background: #fef3c7;
            color: #92400e;
        }

        .status-badge.ltr {
            background: #dbeafe;
            color: #1e40af;
        }

        /* ----- Stats Display ----- */
        .stats-text {
            font-size: 12px;
            color: #64748b;
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- =============================================
         HEADER
         ============================================= -->
    <header class="bg-white border-b border-slate-200 py-4">
        <div class="container mx-auto px-6">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="p-2 bg-slate-100 rounded-lg">
                        <svg class="w-5 h-5 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                        </svg>
                    </div>
                    <div>
                        <h1 class="text-lg font-semibold text-slate-800">Markdown Previewer</h1>
                        <p class="text-xs text-slate-500">MathJax ‚Ä¢ Syntax Highlighting ‚Ä¢ Smart RTL</p>
                    </div>
                </div>
                <div class="flex items-center gap-4 text-xs text-slate-500">
                    <span>üìù Markdown</span>
                    <span>üî¢ LaTeX</span>
                    <span>üîÑ RTL/LTR</span>
                </div>
            </div>
        </div>
    </header>

    <!-- =============================================
         MAIN CONTENT - Editor and Preview Panels
         ============================================= -->
    <main class="container mx-auto px-4 py-6">
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
            
            <!-- Editor Panel -->
            <div class="flex flex-col">
                <!-- Panel Title Bar -->
                <div class="flex items-center justify-between mb-3">
                    <span class="text-sm font-medium text-slate-600">Editor</span>
                    <div class="stats-text" id="stats">
                        <span id="word-count">0 words</span> ¬∑ <span id="char-count">0 chars</span>
                    </div>
                </div>
                
                <!-- Editor Card -->
                <div class="card overflow-hidden flex-1 flex flex-col">
                    <div class="panel-header">
                        <div class="panel-dot red"></div>
                        <div class="panel-dot yellow"></div>
                        <div class="panel-dot green"></div>
                        <span class="text-slate-400 text-xs ml-3 font-mono">document.md</span>
                    </div>
                    <textarea 
                        id="markdown-input" 
                        class="editor-textarea w-full flex-1 p-4 min-h-[550px]"
                        placeholder="Start typing Markdown here..."
                        spellcheck="false"
                    ></textarea>
                </div>
            </div>

            <!-- Preview Panel -->
            <div class="flex flex-col">
                <!-- Panel Title Bar -->
                <div class="flex items-center justify-between mb-3">
                    <span class="text-sm font-medium text-slate-600">Preview</span>
                    <div class="flex items-center gap-2">
                        <span class="stats-text" id="direction-stats">RTL: 0 ¬∑ LTR: 0</span>
                        <div id="direction-indicator">
                            <span class="status-badge ltr">LTR</span>
                        </div>
                    </div>
                </div>
                
                <!-- Preview Card -->
                <div class="card overflow-hidden flex-1 flex flex-col">
                    <div class="flex items-center gap-2 px-4 py-2.5 bg-slate-50 border-b border-slate-200">
                        <div class="flex gap-1.5">
                            <div class="w-2.5 h-2.5 rounded-full bg-rose-400"></div>
                            <div class="w-2.5 h-2.5 rounded-full bg-amber-400"></div>
                            <div class="w-2.5 h-2.5 rounded-full bg-emerald-400"></div>
                        </div>
                        <span class="text-slate-400 text-xs ml-2 font-mono">preview.html</span>
                    </div>
                    <div 
                        id="markdown-output" 
                        class="markdown-body preview-container p-6 min-h-[550px] flex-1"
                    >
                        <p class="text-slate-400 text-center italic">Your preview will appear here...</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- =============================================
         FOOTER
         ============================================= -->
    <footer class="text-center py-4 text-slate-400 text-xs border-t border-slate-100">
        <p>Marked.js ¬∑ MathJax ¬∑ Prism.js</p>
    </footer>

    <!-- =============================================
         JAVASCRIPT
         ============================================= -->
    <script>
        // =============================================
        // UTILITY FUNCTIONS
        // =============================================
        
        /**
         * Escapes HTML special characters to prevent XSS attacks
         * Used when rendering user-provided content
         */
        function escapeHtml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        /**
         * Creates a debounced version of a function
         * Prevents excessive calls during rapid input
         * @param {Function} func - Function to debounce
         * @param {number} wait - Milliseconds to wait before executing
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // =============================================
        // FOOTNOTE EXTENSION FOR MARKED.JS
        // Implements GitHub-style footnotes: [^1] and [^1]: definition
        // =============================================
        
        /**
         * Storage for footnote data during parsing
         * Must be reset before each parse to avoid data leakage
         */
        const footnoteStorage = {
            footnotes: {},      // Map of footnote ID to content
            footnoteRefs: [],   // Ordered list of referenced footnote IDs
            reset() {
                this.footnotes = {};
                this.footnoteRefs = [];
            }
        };

        /**
         * Marked.js extension for footnote references [^1]
         * Captures references in the text and creates superscript links
         */
        const footnoteRefExtension = {
            name: 'footnoteRef',
            level: 'inline',
            start(src) {
                return src.match(/\[\^/)?.index;
            },
            tokenizer(src) {
                // Match [^id] but NOT [^id]: (which is a definition)
                const match = /^\[\^([^\]]+)\](?!\:)/.exec(src);
                if (match) {
                    const id = match[1].trim();
                    // Track reference order for numbering
                    if (!footnoteStorage.footnoteRefs.includes(id)) {
                        footnoteStorage.footnoteRefs.push(id);
                    }
                    return {
                        type: 'footnoteRef',
                        raw: match[0],
                        id: id,
                        refIndex: footnoteStorage.footnoteRefs.indexOf(id) + 1
                    };
                }
            },
            renderer(token) {
                return `<sup class="footnote-ref"><a href="#fn-${token.id}" id="fnref-${token.id}">[${token.refIndex}]</a></sup>`;
            }
        };

        /**
         * Marked.js extension for footnote definitions [^1]: text
         * Captures definitions and stores them for later rendering
         */
        const footnoteDefExtension = {
            name: 'footnoteDef',
            level: 'block',
            start(src) {
                return src.match(/^\[\^[^\]]+\]:/)?.index;
            },
            tokenizer(src) {
                const match = /^\[\^([^\]]+)\]:\s*(.+?)(?:\n|$)/.exec(src);
                if (match) {
                    const id = match[1].trim();
                    const content = match[2].trim();
                    // Store definition for later use
                    footnoteStorage.footnotes[id] = content;
                    return {
                        type: 'footnoteDef',
                        raw: match[0],
                        id: id,
                        content: content
                    };
                }
            },
            renderer(token) {
                // Don't render anything inline - footnotes appear at the bottom
                return '';
            }
        };

        /**
         * Generates the footnotes section HTML
         * Called after main content parsing to append footnotes at the bottom
         */
        function appendFootnotesSection(html) {
            const ids = footnoteStorage.footnoteRefs;
            if (ids.length === 0) return html;
            
            let footnotesHtml = '<section class="footnotes"><ol>';
            ids.forEach((id, index) => {
                const content = footnoteStorage.footnotes[id] || 'Footnote not defined';
                const parsedContent = marked.parseInline(content);
                footnotesHtml += `<li id="fn-${id}"><p>${parsedContent} <a href="#fnref-${id}" class="footnote-backref">‚Ü©</a></p></li>`;
            });
            footnotesHtml += '</ol></section>';
            
            return html + footnotesHtml;
        }

        // =============================================
        // MARKED.JS CONFIGURATION
        // =============================================
        
        marked.use({
            breaks: true,   // Convert single line breaks to <br>
            gfm: true,      // Enable GitHub Flavored Markdown
            extensions: [footnoteRefExtension, footnoteDefExtension],
            renderer: {
                /**
                 * Custom code block renderer with Prism.js syntax highlighting
                 */
                code({text, lang, escaped}) {
                    const langClass = lang ? escapeHtml(lang.split(/\s/)[0]) : 'plaintext';
                    let highlighted;
            
                    // Use Prism if language is supported
                    if (lang && Prism.languages[lang]) {
                        try {
                            highlighted = Prism.highlight(text, Prism.languages[lang], lang);
                        } catch (e) {
                            console.error('Prism highlighting error:', e);
                            highlighted = escaped ? text : escapeHtml(text);
                        }
                    } else {
                        highlighted = escaped ? text : escapeHtml(text);
                    }
            
                    return `<pre class="language-${langClass}"><code class="language-${langClass}">${highlighted}</code></pre>`;
                }
            }
        });

        /**
         * Wraps tables in scrollable containers for responsive display
         */
        function wrapTables(html) {
            return html
                .replace(/<table>/g, '<div class="table-wrapper"><table>')
                .replace(/<\/table>/g, '</table></div>');
        }
        
        // =============================================
        // DOM ELEMENT REFERENCES
        // =============================================
        
        const markdownInput = document.getElementById('markdown-input');
        const markdownOutput = document.getElementById('markdown-output');
        const directionIndicator = document.getElementById('direction-indicator');
        const directionStats = document.getElementById('direction-stats');
        const wordCountEl = document.getElementById('word-count');
        const charCountEl = document.getElementById('char-count');

        // =============================================
        // RTL/LTR DIRECTION DETECTION
        // =============================================

        // Unicode ranges for Persian/Arabic characters
        const PERSIAN_ARABIC_PATTERN = /[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]/g;
        
        // Unicode ranges for Latin characters (including extended Latin)
        const LATIN_PATTERN = /[A-Za-z\u00C0-\u024F]/g;

        /**
         * Counts Persian/Arabic vs Latin characters in text
         * Strips out code, math, URLs, and punctuation before counting
         */
        function countCharacterTypes(text) {
            // Remove content that shouldn't affect direction detection
            const cleanText = text
                .replace(/<[^>]*>/g, '')              // HTML tags
                .replace(/\$\$[\s\S]*?\$\$/g, '')     // Block math
                .replace(/\$[^$]+\$/g, '')            // Inline math
                .replace(/`[^`]+`/g, '')              // Inline code
                .replace(/```[\s\S]*?```/g, '')       // Code blocks
                .replace(/https?:\/\/[^\s]+/g, '')    // URLs
                .replace(/[0-9\s\p{P}\p{S}]/gu, '');  // Numbers, spaces, punctuation
            
            const persianMatches = cleanText.match(PERSIAN_ARABIC_PATTERN) || [];
            const latinMatches = cleanText.match(LATIN_PATTERN) || [];
            
            return {
                persian: persianMatches.length,
                latin: latinMatches.length
            };
        }

        /**
         * Determines text direction based on character majority
         * Returns 'rtl' if Persian/Arabic characters dominate, otherwise 'ltr'
         */
        function getElementDirection(text) {
            const counts = countCharacterTypes(text);
            
            // Default to LTR if no significant characters found
            if (counts.persian === 0 && counts.latin === 0) {
                return 'ltr';
            }
            
            return counts.persian > counts.latin ? 'rtl' : 'ltr';
        }

        /**
         * Applies direction attribute to each block element individually
         * This allows mixed RTL/LTR content to display correctly
         */
        function applyPerBlockDirection(container) {
            let rtlCount = 0;
            let ltrCount = 0;
            
            // Block elements that should have direction applied
            const blockSelectors = [
                'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                'li', 'blockquote', 'th', 'td'
            ];
            
            // Apply direction to list containers
            const lists = container.querySelectorAll('ul, ol');
            lists.forEach(list => {
                const listText = list.textContent || '';
                const direction = getElementDirection(listText);
                list.setAttribute('dir', direction);
                if (direction === 'rtl') rtlCount++; else ltrCount++;
            });
            
            // Apply direction to each block element
            blockSelectors.forEach(selector => {
                const elements = container.querySelectorAll(selector);
                elements.forEach(el => {
                    // Skip elements inside code blocks
                    if (el.closest('pre') || el.closest('code')) {
                        return;
                    }
                    
                    const text = el.textContent || '';
                    const direction = getElementDirection(text);
                    
                    el.setAttribute('dir', direction);
                    
                    if (direction === 'rtl') {
                        rtlCount++;
                    } else {
                        ltrCount++;
                    }
                });
            });
            
            return { rtlCount, ltrCount };
        }

        // =============================================
        // BIDIRECTIONAL TEXT ISOLATION
        // Fixes display issues when Latin text appears within RTL content
        // =============================================
        
        /**
         * Isolates Latin character sequences within RTL elements using <bdi> tags
         * 
         * Problem: When Latin text like "C++" or "my name is amin" appears in RTL context,
         * browsers may incorrectly reverse the character/word order.
         * 
         * Solution: Wrap Latin sequences in <bdi> (bidirectional isolate) elements
         * which prevents the RTL context from affecting their display order.
         * 
         * IMPORTANT: Must run AFTER MathJax rendering to avoid breaking math elements
         */
        function isolateLatinInRTL(container) {
            const rtlElements = container.querySelectorAll('[dir="rtl"]');
            
            rtlElements.forEach(el => {
                // Skip code elements - they handle their own direction
                if (el.tagName === 'PRE' || el.tagName === 'CODE') return;
                if (el.closest('pre') || el.closest('code')) return;
                
                // Collect all text nodes (avoid modifying DOM while iterating)
                const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
                const textNodes = [];
                let currentNode;
                
                while (currentNode = walker.nextNode()) {
                    const parent = currentNode.parentElement;
                    // Skip text inside elements that shouldn't be processed
                    if (parent && !parent.closest('code, pre, bdi, mjx-container, mjx-math, mjx-mrow, mjx-mi, mjx-mo, mjx-mn, mjx-mtext, mjx-msup, mjx-msub, mjx-mfrac, mjx-msqrt, mjx-mroot, mjx-mtable, mjx-mtr, mjx-mtd, script, style')) {
                        textNodes.push(currentNode);
                    }
                }
                
                // Process each text node
                textNodes.forEach(textNode => {
                    const text = textNode.textContent;
                    
                    /**
                     * Regex explanation:
                     * - [^\s\u0600-\u06FF...]* - Optional non-RTL, non-space chars before (like ++, @, etc.)
                     * - [A-Za-z] - At least one Latin letter (required)
                     * - [^\s\u0600-\u06FF...]* - Optional non-RTL, non-space chars after
                     * - (?:\s+...)* - Optionally repeat for multiple words separated by spaces
                     * 
                     * This captures: "C++", "++C", "@user", "my name is amin", "C++ programming"
                     */
                    const regex = /[^\s\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]*[A-Za-z][^\s\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]*(?:\s+[^\s\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]*[A-Za-z][^\s\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]*)*/g;
                    
                    if (!regex.test(text)) return;
                    regex.lastIndex = 0;  // Reset regex state
                    
                    const fragment = document.createDocumentFragment();
                    let lastIndex = 0;
                    let match;
                    let hasMatches = false;
                    
                    while ((match = regex.exec(text)) !== null) {
                        hasMatches = true;
                        
                        // Add text before the match (Persian text)
                        if (match.index > lastIndex) {
                            fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
                        }
                        
                        let matchedText = match[0];
                        let trailingPunct = '';
                        
                        /**
                         * Strip trailing sentence punctuation from the isolated block
                         * Punctuation like . ! ? , should stay in RTL context for proper placement
                         * Example: "test." should become <bdi>test</bdi>. not <bdi>test.</bdi>
                         */
                        const trailingMatch = matchedText.match(/[.!?,;:]+$/);
                        if (trailingMatch) {
                            trailingPunct = trailingMatch[0];
                            matchedText = matchedText.slice(0, -trailingPunct.length);
                        }
                        
                        // Wrap Latin sequence in <bdi> for bidirectional isolation
                        if (matchedText) {
                            const bdi = document.createElement('bdi');
                            bdi.textContent = matchedText;
                            fragment.appendChild(bdi);
                        }
                        
                        // Add punctuation outside the isolation (stays in RTL context)
                        if (trailingPunct) {
                            fragment.appendChild(document.createTextNode(trailingPunct));
                        }
                        
                        lastIndex = regex.lastIndex;
                    }
                    
                    // Add remaining text after last match
                    if (lastIndex < text.length) {
                        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }
                    
                    // Replace original text node with processed fragment
                    if (hasMatches && textNode.parentNode) {
                        textNode.parentNode.replaceChild(fragment, textNode);
                    }
                });
            });
        }

        // =============================================
        // UI UPDATE FUNCTIONS
        // =============================================

        /**
         * Updates the direction indicator badge in the UI
         */
        function updateDirectionIndicator(rtlCount, ltrCount) {
            const total = rtlCount + ltrCount;
            let badgeClass, label;
            
            if (total === 0) {
                badgeClass = 'ltr';
                label = 'LTR';
            } else if (rtlCount > 0 && ltrCount > 0) {
                badgeClass = 'mixed';
                label = 'Mixed';
            } else if (rtlCount > ltrCount) {
                badgeClass = 'rtl';
                label = 'RTL';
            } else {
                badgeClass = 'ltr';
                label = 'LTR';
            }
            
            directionIndicator.innerHTML = `<span class="status-badge ${badgeClass}">${label}</span>`;
            directionStats.textContent = `RTL: ${rtlCount} ¬∑ LTR: ${ltrCount}`;
        }

        /**
         * Updates word and character count display
         */
        function updateStats(text) {
            const chars = text.length;
            const words = text.trim() ? text.trim().split(/\s+/).length : 0;
            wordCountEl.textContent = `${words} words`;
            charCountEl.textContent = `${chars} chars`;
        }

        // =============================================
        // MATH EXPRESSION HANDLING
        // Protects math from being processed by Markdown parser
        // =============================================

        /**
         * Temporarily replaces math expressions with placeholders
         * This prevents Markdown parser from corrupting LaTeX syntax
         */
        function escapeMath(text) {
            const mathBlocks = [];
            const inlineMaths = [];
            
            // Escape block math $$...$$ (can be multiline)
            text = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, math) => {
                mathBlocks.push(match);
                return `%%MATHBLOCK${mathBlocks.length - 1}%%`;
            });
            
            // Escape inline math $...$ (single line only)
            text = text.replace(/\$([^\$\n]+?)\$/g, (match, math) => {
                inlineMaths.push(match);
                return `%%MATHINLINE${inlineMaths.length - 1}%%`;
            });
            
            return { text, mathBlocks, inlineMaths };
        }

        /**
         * Restores math expressions after Markdown parsing
         */
        function restoreMath(html, mathBlocks, inlineMaths) {
            mathBlocks.forEach((math, i) => {
                html = html.replace(`%%MATHBLOCK${i}%%`, math);
            });
            
            inlineMaths.forEach((math, i) => {
                html = html.replace(`%%MATHINLINE${i}%%`, math);
            });
            
            return html;
        }

        // =============================================
        // MAIN UPDATE FUNCTION
        // Orchestrates the entire preview rendering pipeline
        // =============================================

        function updatePreview() {
            const rawMarkdown = markdownInput.value;
            
            // Update statistics
            updateStats(rawMarkdown);
            
            // Handle empty input
            if (rawMarkdown.trim() === '') {
                markdownOutput.innerHTML = '<p class="text-slate-400 text-center italic">Your preview will appear here...</p>';
                updateDirectionIndicator(0, 0);
                return;
            }
            
            // Reset footnote storage for fresh parse
            footnoteStorage.reset();
            
            // Step 1: Protect math expressions from Markdown parser
            const { text, mathBlocks, inlineMaths } = escapeMath(rawMarkdown);
            
            // Step 2: Parse Markdown to HTML
            let html = marked.parse(text);
            
            // Step 3: Restore math expressions
            html = restoreMath(html, mathBlocks, inlineMaths);
            
            // Step 4: Wrap tables for responsive scrolling
            html = wrapTables(html);
            
            // Step 5: Add footnotes section at the bottom
            html = appendFootnotesSection(html);
            
            // Step 6: Render to DOM
            markdownOutput.innerHTML = html;
            
            // Step 7: Apply per-block RTL/LTR direction
            const directionCounts = applyPerBlockDirection(markdownOutput);
            updateDirectionIndicator(directionCounts.rtlCount, directionCounts.ltrCount);
            
            // Step 8: Apply syntax highlighting to code blocks
            Prism.highlightAllUnder(markdownOutput);
            
            // Step 9: Render math with MathJax, then fix bidirectional text
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetClear([markdownOutput]);
                MathJax.typesetPromise([markdownOutput])
                    .then(() => {
                        // Must run AFTER MathJax to avoid breaking math elements
                        isolateLatinInRTL(markdownOutput);
                    })
                    .catch((err) => {
                        console.error('MathJax error:', err);
                        // Still try to fix bidi even if MathJax fails
                        isolateLatinInRTL(markdownOutput);
                    });
            } else {
                // MathJax not available, just fix bidi
                isolateLatinInRTL(markdownOutput);
            }
        }

        // =============================================
        // EVENT LISTENERS
        // =============================================

        // Debounce input to prevent excessive re-renders during fast typing
        const debouncedUpdate = debounce(updatePreview, 150);
        markdownInput.addEventListener('input', debouncedUpdate);

        // Handle paste events with immediate update
        markdownInput.addEventListener('paste', () => setTimeout(updatePreview, 0));

        // =============================================
        // SAMPLE CONTENT
        // Demonstrates various features of the previewer
        // =============================================

        const sampleMarkdown = `# Markdown Previewer

A **powerful** editor with *real-time preview*, LaTeX math, syntax highlighting, and **smart RTL detection**.

---

## Math Examples

Inline math: $E = mc^2$ and $x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$

Block equation:

$$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$

---

## ÿ®ÿÆÿ¥ ŸÅÿßÿ±ÿ≥€å

ŸÖÿπÿßÿØŸÑ€Ä ÿßŸÜ€åÿ¥ÿ™€åŸÜ $E = mc^2$ ŸÅ€åÿ≤€å⁄© ÿ±ÿß ŸÖÿ™ÿ≠ŸàŸÑ ⁄©ÿ±ÿØ.

$$\\nabla \\times \\vec{E} = -\\frac{\\partial \\vec{B}}{\\partial t}$$

### ⁄©ÿØ ÿØÿ± ŸÖÿ™ŸÜ ŸÅÿßÿ±ÿ≥€å

ÿ®ÿ±ÿß€å ÿßÿ¨ÿ±ÿß€å ÿ®ÿ±ŸÜÿßŸÖŸá ÿßÿ≤ \`npm start\` ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ€åÿØ.

ÿ≤ÿ®ÿßŸÜ‚ÄåŸáÿß€å ÿ®ÿ±ŸÜÿßŸÖŸá‚ÄåŸÜŸà€åÿ≥€å ŸÖÿ´ŸÑ C++ Ÿà Python Ÿà JavaScript ŸÖÿ≠ÿ®Ÿàÿ® Ÿáÿ≥ÿ™ŸÜÿØ.

---

## Code Examples

\`\`\`javascript
async function fetchData(url) {
    const response = await fetch(url);
    return response.json();
}
\`\`\`

\`\`\`python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
\`\`\`

---

## Footnotes

The theory of relativity[^1] changed physics forever.

[^1]: Published by Einstein in 1905.

---

## Table

| Feature | Status |
|---------|--------|
| Markdown | ‚úÖ |
| MathJax | ‚úÖ |
| RTL | ‚úÖ |

---

## Lists

1. First item
2. Second item with \`code\`
3. Third item with $x^2$

- Item with **bold**
- Item with *italic*

### ŸÑ€åÿ≥ÿ™ ŸÅÿßÿ±ÿ≥€å

- ŸÖŸàÿ±ÿØ ÿßŸàŸÑ
- ŸÖŸàÿ±ÿØ ÿØŸàŸÖ
- ŸÖŸàÿ±ÿØ ÿ≥ŸàŸÖ

---

> "The only way to do great work is to love what you do."

> üìù **ŸÜ⁄©ÿ™Ÿá:** ŸÖÿ™ŸÜ ŸÅÿßÿ±ÿ≥€å ÿØÿ± blockquote`;

        // Initialize with sample content
        markdownInput.value = sampleMarkdown;
        
        // Render after page and MathJax are ready
        if (document.readyState === 'complete') {
            setTimeout(updatePreview, 500);
        } else {
            window.addEventListener('load', () => setTimeout(updatePreview, 500));
        }
    </script>
</body>
</html>
